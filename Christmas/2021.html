<!doctype html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Christmas Card 2021</title>
    <link rel="stylesheet" href="https://js.arcgis.com/calcite-components/1.0.0-beta.71/calcite.css" />
    <script src="https://js.arcgis.com/calcite-components/1.0.0-beta.71/calcite.js" type=module></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix.js"></script>

    <link rel="stylesheet" href="https://js.arcgis.com/4.22/esri/themes/light/main.css">
    <script src="https://js.arcgis.com/4.22/"></script>


    <style>
       
        html,
        body,
        #mapDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        #header {
            padding-left: 10px;
            background-image: url(christmas_background.png);
            border-bottom: solid 3px #FFFFFF;
            color: var(--calcite-ui-foreground-3);
            text-shadow: 1px 1px 10px #fff, 1px 1px 10px #ccc;
        }

        #footer {
            padding: 10px 5px 10px 5px;
            background-color: var(--calcite-ui-background);
            border-top: solid 1px var(--calcite-ui-border-1);

        }

        /*Remove the black bar from the map*/
        #mapDiv .esri-view-surface:focus::after {
            outline: auto 0px !important;
        }

        .esri-logo {
            margin: 0.375 rem;
            content: "";
            display: inline-block;
            background-repeat: no-repeat;
            background-position: center;
            background-color: transparent;
            min-height: 30px;
            min-width: 70px;
            line-height: 0;
            background-size: 100% 100%;
            background-image: url(esri-logo.svg);
        }
    </style>
    <script>
        //API Key account: mvanhulzen_esrinl
        const apiKey = "AAPK8195e5c382714413afffd8786a2e81963znoAuzAUh82CmnUyvKuggBmE5U18ISQBp-0lvE92yPTzQn1MGZRRK3feyk3VS5l";
        const routeServiceUrl = "https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/"

        const xOffset = 1500;
        const yOffset = 3000;
        var ballFLayer = null;
        var treeFLayer = null;
        var textFLayer = null;
        var customTreeLayer = null;
        var tempBallLayer = null;
        var tempTreeLayer = null;
        var tempCustomTreeLayer = null;

        var currentHue = 0;
        var currentHueDelta = 5;
        var origEffectString = "";
        require([
            "esri/Map",
            "esri/WebMap",
            "esri/Graphic",
            "esri/layers/GraphicsLayer",
            "esri/layers/FeatureLayer",
            "esri/views/MapView",
            "esri/rest/route",
            "esri/rest/support/RouteParameters",
            "esri/rest/support/FeatureSet",
            "esri/rest/networkService",
            "esri/views/2d/layers/BaseLayerViewGL2D",
            "esri/core/watchUtils",
        "esri/geometry/geometryEngine"],
            (Map,
                WebMap,
                Graphic,
                GraphicsLayer,
                FeatureLayer,
                MapView,
                route,
                RouteParameters,
                FeatureSet, networkService,
                BaseLayerViewGL2D,
                watchUtils,
                geometryEngine) => {

                const CustomLayerView2D = BaseLayerViewGL2D.createSubclass({
                    // Locations of the two vertex attributes that we use. They
                    // will be bound to the shader program before linking.
                    aPosition: 0,
                    aOffset: 1,
                    aDistance: 2,
                    aSide: 3,
                    aColor: 4,

                    constructor: function () {
                        // Geometrical transformations that must be recomputed
                        // from scratch at every frame.
                        this.transform = mat3.create();
                        this.extrude = mat3.create();
                        this.translationToCenter = vec2.create();
                        this.screenTranslation = vec2.create();

                        // Geometrical transformations whose only a few elements
                        // must be updated per frame. Those elements are marked
                        // with NaN.
                        this.display = mat3.fromValues(NaN, 0, 0, 0, NaN, 0, -1, 1, 1);
                        this.screenScaling = vec3.fromValues(NaN, NaN, 1);

                        // Whether the vertex and index buffers need to be updated
                        // due to a change in the layer data.
                        this.needsUpdate = false;

                        // We listen for changes to the graphics collection of the layer
                        // and trigger the generation of new frames. A frame rendered while
                        // `needsUpdate` is true may cause an update of the vertex and
                        // index buffers.
                        const requestUpdate = () => {
                            this.needsUpdate = true;
                            this.requestRender();
                        };

                        this.watcher = watchUtils.on(
                            this,
                            "layer.graphics",
                            "change",
                            requestUpdate,
                            requestUpdate,
                            requestUpdate
                        );
                    },

                    // Called once a custom layer is added to the map.layers collection and this layer view is instantiated.
                    attach: function () {
                        const gl = this.context;

                        const vertexSource = `
              precision highp float;

              uniform mat3 u_transform;
              uniform mat3 u_extrude;
              uniform mat3 u_display;

              attribute vec2 a_position;
              attribute vec2 a_offset;
              attribute float a_distance;
              attribute float a_side;
              attribute vec4 a_color;

              varying float v_distance;
              varying float v_side;
              varying vec4 v_color;

              void main(void) {
                gl_Position.xy = (u_display * (u_transform * vec3(a_position, 1.0) + u_extrude * vec3(a_offset, 0.0))).xy;
                gl_Position.zw = vec2(0.0, 1.0);
                v_distance = a_distance;
                v_side = a_side;
                v_color = a_color;
              }`;

                        const fragmentSource = `
              precision highp float;

              uniform float u_current_time;

              varying float v_distance;
              varying float v_side;
              varying vec4 v_color;

              //const float TRAIL_SPEED = 50.0;
              //const float TRAIL_LENGTH = 300.0;
              //const float TRAIL_CYCLE = 1000.0;
              const float TRAIL_SPEED = 200.0;
              const float TRAIL_LENGTH = 1500.0;
              const float TRAIL_CYCLE = 1500.0;

              void main(void) {
                float d = mod(v_distance - u_current_time * TRAIL_SPEED, TRAIL_CYCLE);
                float a1 = d < TRAIL_LENGTH ? mix(0.0, 1.0, d / TRAIL_LENGTH) : 0.0;
                float a2 = exp(-abs(v_side) * 3.0);
                float a = a1 * a2;
                gl_FragColor = v_color * a;
              }`;

                        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                        gl.shaderSource(vertexShader, vertexSource);
                        gl.compileShader(vertexShader);
                        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                        gl.shaderSource(fragmentShader, fragmentSource);
                        gl.compileShader(fragmentShader);

                        // Create the shader program.
                        this.program = gl.createProgram();
                        gl.attachShader(this.program, vertexShader);
                        gl.attachShader(this.program, fragmentShader);

                        // Bind attributes.
                        gl.bindAttribLocation(this.program, this.aPosition, "a_position");
                        gl.bindAttribLocation(this.program, this.aOffset, "a_offset");
                        gl.bindAttribLocation(this.program, this.aDistance, "a_distance");
                        gl.bindAttribLocation(this.program, this.aSide, "a_side");
                        gl.bindAttribLocation(this.program, this.aColor, "a_color");

                        // Link.
                        gl.linkProgram(this.program);

                        // Shader objects are not needed anymore.
                        gl.deleteShader(vertexShader);
                        gl.deleteShader(fragmentShader);

                        // Retrieve uniform locations once and for all.
                        this.uTransform = gl.getUniformLocation(
                            this.program,
                            "u_transform"
                        );
                        this.uExtrude = gl.getUniformLocation(this.program, "u_extrude");
                        this.uDisplay = gl.getUniformLocation(this.program, "u_display");
                        this.uCurrentTime = gl.getUniformLocation(
                            this.program,
                            "u_current_time"
                        );

                        // Create the vertex and index buffer. They are initially empty. We need to track the
                        // size of the index buffer because we use indexed drawing.
                        this.vertexBuffer = gl.createBuffer();
                        this.indexBuffer = gl.createBuffer();

                        // Number of indices in the index buffer.
                        this.indexBufferSize = 0;

                        // When certain conditions occur, we update the buffers and re-compute and re-encode
                        // all the attributes. When buffer update occurs, we also take note of the current center
                        // of the view state, and we reset a vector called `translationToCenter` to [0, 0], meaning that the
                        // current center is the same as it was when the attributes were recomputed.
                        this.centerAtLastUpdate = vec2.fromValues(
                            this.view.state.center[0],
                            this.view.state.center[1]
                        );
                    },

                    // Called once a custom layer is removed from the map.layers collection and this layer view is destroyed.
                    detach: function () {
                        // Stop watching the `layer.graphics` collection.
                        this.watcher.remove();

                        const gl = this.context;

                        // Delete buffers and programs.
                        gl.deleteBuffer(this.vertexBuffer);
                        gl.deleteBuffer(this.indexBuffer);
                        gl.deleteProgram(this.program);
                    },

                    // Called every time a frame is rendered.
                    render: function (renderParameters) {
                        const gl = renderParameters.context;
                        const state = renderParameters.state;

                        // Update vertex positions. This may trigger an update of
                        // the vertex coordinates contained in the vertex buffer.
                        // There are three kinds of updates:
                        //  - Modification of the layer.graphics collection ==> Buffer update
                        //  - The view state becomes non-stationary ==> Only view update, no buffer update
                        //  - The view state becomes stationary ==> Buffer update
                        this.updatePositions(renderParameters);

                        // If there is nothing to render we return.
                        if (this.indexBufferSize === 0) {
                            return;
                        }

                        // Update view `transform` matrix; it converts from map units to pixels.
                        mat3.identity(this.transform);
                        this.screenTranslation[0] = (state.pixelRatio * state.size[0]) / 2;
                        this.screenTranslation[1] = (state.pixelRatio * state.size[1]) / 2;
                        mat3.translate(
                            this.transform,
                            this.transform,
                            this.screenTranslation
                        );
                        mat3.rotate(
                            this.transform,
                            this.transform,
                            (Math.PI * state.rotation) / 180
                        );
                        this.screenScaling[0] = state.pixelRatio / state.resolution;
                        this.screenScaling[1] = -state.pixelRatio / state.resolution;
                        mat3.scale(this.transform, this.transform, this.screenScaling);
                        mat3.translate(
                            this.transform,
                            this.transform,
                            this.translationToCenter
                        );

                        // Update view `extrude` matrix; it causes offset vectors to rotate and scale
                        // with the view, but caps the maximum width a polyline is allowed to be.
                        mat3.identity(this.extrude);
                        mat3.rotate(
                            this.extrude,
                            this.extrude,
                            (Math.PI * state.rotation) / 180
                        );
                        const HALF_WIDTH = 6;
                        mat3.scale(this.extrude, this.extrude, [
                            HALF_WIDTH,
                            -HALF_WIDTH,
                            1
                        ]);

                        // Update view `display` matrix; it converts from pixels to normalized device coordinates.
                        this.display[0] = 2 / (state.pixelRatio * state.size[0]);
                        this.display[4] = -2 / (state.pixelRatio * state.size[1]);

                        // Draw.
                        gl.useProgram(this.program);
                        gl.uniformMatrix3fv(this.uTransform, false, this.transform);
                        gl.uniformMatrix3fv(this.uExtrude, false, this.extrude);
                        gl.uniformMatrix3fv(this.uDisplay, false, this.display);
                        gl.uniform1f(this.uCurrentTime, performance.now() / 1000.0);
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        gl.enableVertexAttribArray(this.aPosition);
                        gl.enableVertexAttribArray(this.aOffset);
                        gl.enableVertexAttribArray(this.aDistance);
                        gl.enableVertexAttribArray(this.aSide);
                        gl.enableVertexAttribArray(this.aColor);
                        gl.vertexAttribPointer(this.aPosition, 2, gl.FLOAT, false, 28, 0);
                        gl.vertexAttribPointer(this.aOffset, 2, gl.FLOAT, false, 28, 8);
                        gl.vertexAttribPointer(this.aDistance, 1, gl.FLOAT, false, 28, 16);
                        gl.vertexAttribPointer(this.aSide, 1, gl.FLOAT, false, 28, 20);
                        gl.vertexAttribPointer(
                            this.aColor,
                            4,
                            gl.UNSIGNED_BYTE,
                            true,
                            28,
                            24
                        );
                        gl.enable(gl.BLEND);
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        gl.drawElements(
                            gl.TRIANGLES,
                            this.indexBufferSize,
                            gl.UNSIGNED_SHORT,
                            0
                        );

                        // Request new render because markers are animated.
                        this.requestRender();
                    },

                    // Called internally from render().
                    updatePositions: function (renderParameters) {
                        const gl = renderParameters.context;
                        const stationary = renderParameters.stationary;
                        const state = renderParameters.state;

                        // If we are not stationary we simply update the `translationToCenter` vector.
                        if (!stationary) {
                            vec2.sub(
                                this.translationToCenter,
                                this.centerAtLastUpdate,
                                state.center
                            );
                            this.requestRender();
                            return;
                        }

                        // If we are stationary, the `layer.graphics` collection has not changed, and
                        // we are centered on the `centerAtLastUpdate`, we do nothing.
                        if (
                            !this.needsUpdate &&
                            this.translationToCenter[0] === 0 &&
                            this.translationToCenter[1] === 0
                        ) {
                            return;
                        }

                        // Otherwise, we record the new encoded center, which imply a reset of the `translationToCenter` vector,
                        // we record the update time, and we proceed to update the buffers.
                        this.centerAtLastUpdate.set(state.center);
                        this.translationToCenter[0] = 0;
                        this.translationToCenter[1] = 0;
                        this.needsUpdate = false;

                        const graphics = this.layer.graphics;

                        // Allocate memory.
                        let vtxCount = 0;
                        let idxCount = 0;

                        for (let i = 0; i < graphics.items.length; ++i) {
                            const graphic = graphics.items[i];
                            const path = graphic.geometry.paths[0];

                            vtxCount += path.length * 2;
                            idxCount += (path.length - 1) * 6;
                        }

                        const vertexData = new ArrayBuffer(7 * vtxCount * 4);
                        const floatData = new Float32Array(vertexData);
                        const colorData = new Uint8Array(vertexData);
                        const indexData = new Uint16Array(idxCount);

                        // Generate attribute and index data. These cursors count the number
                        // of GPU vertices and indices emitted by the triangulator; writes to
                        // vertex and index memory occur at the positions pointed by the cursors.
                        let vtxCursor = 0;
                        let idxCursor = 0;

                        for (let i = 0; i < graphics.items.length; ++i) {
                            const graphic = graphics.items[i];
                            const path = graphic.geometry.paths[0];
                            const color = graphic.attributes["color"];

                            // Initialize new triangulation state.
                            let s = {};

                            // Process each vertex.
                            for (let j = 0; j < path.length; ++j) {
                                // Point p is an original vertex of the polyline; we need to produce two extruded
                                // GPU vertices, for each original vertex.
                                const p = path[j];

                                if (s.current) {
                                    // If this is not the first point, we compute the vector between the previous
                                    // and the next vertex.
                                    s.delta = [p[0] - s.current[0], p[1] - s.current[1]];

                                    // And we normalize it. This is the direction of the current line segment
                                    // that we are processing.
                                    const deltaLength = Math.sqrt(
                                        s.delta[0] * s.delta[0] + s.delta[1] * s.delta[1]
                                    );
                                    s.direction = [
                                        s.delta[0] / deltaLength,
                                        s.delta[1] / deltaLength
                                    ];

                                    // We want to compute the normal to that segment. The normal of a
                                    // vector (x, y) can be computed by rotating it by 90 degrees; this yields (-y, x).
                                    const normal = [-s.direction[1], s.direction[0]];

                                    if (s.normal) {
                                        // If there is already a normal vector in the state, then the offset is the
                                        // average of that normal and the next normal, i.e. the bisector of the turn.
                                        s.offset = [
                                            s.normal[0] + normal[0],
                                            s.normal[1] + normal[1]
                                        ];

                                        // We first normalize it.
                                        const offsetLength = Math.sqrt(
                                            s.offset[0] * s.offset[0] + s.offset[1] * s.offset[1]
                                        );
                                        s.offset[0] /= offsetLength;
                                        s.offset[1] /= offsetLength;

                                        // Then we scale it like the cosine of the half turn angle. This can
                                        // be computed as the dot product between the previous normal and the
                                        // normalized bisector.
                                        const d =
                                            s.normal[0] * s.offset[0] + s.normal[1] * s.offset[1];
                                        s.offset[0] /= d;
                                        s.offset[1] /= d;
                                    } else {
                                        // Otherwise, this is the offset of the first vertex; it is equal to the
                                        // normal we just computed.
                                        s.offset = [normal[0], normal[1]];
                                    }

                                    // All the values that we computed are written to the first GPU vertex.
                                    floatData[vtxCursor * 7 + 0] =
                                        s.current[0] - this.centerAtLastUpdate[0];
                                    floatData[vtxCursor * 7 + 1] =
                                        s.current[1] - this.centerAtLastUpdate[1];
                                    floatData[vtxCursor * 7 + 2] = s.offset[0];
                                    floatData[vtxCursor * 7 + 3] = s.offset[1];
                                    floatData[vtxCursor * 7 + 4] = s.distance;
                                    floatData[vtxCursor * 7 + 5] = +1;
                                    colorData[4 * (vtxCursor * 7 + 6) + 0] = color[0];
                                    colorData[4 * (vtxCursor * 7 + 6) + 1] = color[1];
                                    colorData[4 * (vtxCursor * 7 + 6) + 2] = color[2];
                                    colorData[4 * (vtxCursor * 7 + 6) + 3] = 255;

                                    // We also write the same values to the second vertex, but we negate the
                                    // offset and the side (these are the attributes at positions +9, +10 and +12).
                                    floatData[vtxCursor * 7 + 7] =
                                        s.current[0] - this.centerAtLastUpdate[0];
                                    floatData[vtxCursor * 7 + 8] =
                                        s.current[1] - this.centerAtLastUpdate[1];
                                    floatData[vtxCursor * 7 + 9] = -s.offset[0];
                                    floatData[vtxCursor * 7 + 10] = -s.offset[1];
                                    floatData[vtxCursor * 7 + 11] = s.distance;
                                    floatData[vtxCursor * 7 + 12] = -1;
                                    colorData[4 * (vtxCursor * 7 + 13) + 0] = color[0];
                                    colorData[4 * (vtxCursor * 7 + 13) + 1] = color[1];
                                    colorData[4 * (vtxCursor * 7 + 13) + 2] = color[2];
                                    colorData[4 * (vtxCursor * 7 + 13) + 3] = 255;
                                    vtxCursor += 2;

                                    if (j >= 2) {
                                        // If this is the third iteration then it means that we have emitted
                                        // four GPU vertices already; we can form a triangle with them.
                                        indexData[idxCursor + 0] = vtxCursor - 4;
                                        indexData[idxCursor + 1] = vtxCursor - 3;
                                        indexData[idxCursor + 2] = vtxCursor - 2;
                                        indexData[idxCursor + 3] = vtxCursor - 3;
                                        indexData[idxCursor + 4] = vtxCursor - 1;
                                        indexData[idxCursor + 5] = vtxCursor - 2;
                                        idxCursor += 6;
                                    }

                                    // The next normal becomes the current normal at the next iteration.
                                    s.normal = normal;

                                    // We increment the distance along the line by the length of the segment
                                    // that we just processed.
                                    s.distance += deltaLength;
                                } else {
                                    s.distance = 0;
                                }

                                // We move to the next point.
                                s.current = p;
                            }

                            // Finishing up (last 2 extruded vertices and 6 indices).
                            s.offset = [s.normal[0], s.normal[1]];
                            floatData[vtxCursor * 7 + 0] =
                                s.current[0] - this.centerAtLastUpdate[0];
                            floatData[vtxCursor * 7 + 1] =
                                s.current[1] - this.centerAtLastUpdate[1];
                            floatData[vtxCursor * 7 + 2] = s.offset[0];
                            floatData[vtxCursor * 7 + 3] = s.offset[1];
                            floatData[vtxCursor * 7 + 4] = s.distance;
                            floatData[vtxCursor * 7 + 5] = +1;
                            colorData[4 * (vtxCursor * 7 + 6) + 0] = color[0];
                            colorData[4 * (vtxCursor * 7 + 6) + 1] = color[1];
                            colorData[4 * (vtxCursor * 7 + 6) + 2] = color[2];
                            colorData[4 * (vtxCursor * 7 + 6) + 3] = 255;
                            floatData[vtxCursor * 7 + 7] =
                                s.current[0] - this.centerAtLastUpdate[0];
                            floatData[vtxCursor * 7 + 8] =
                                s.current[1] - this.centerAtLastUpdate[1];
                            floatData[vtxCursor * 7 + 9] = -s.offset[0];
                            floatData[vtxCursor * 7 + 10] = -s.offset[1];
                            floatData[vtxCursor * 7 + 11] = s.distance;
                            floatData[vtxCursor * 7 + 12] = -1;
                            colorData[4 * (vtxCursor * 7 + 13) + 0] = color[0];
                            colorData[4 * (vtxCursor * 7 + 13) + 1] = color[1];
                            colorData[4 * (vtxCursor * 7 + 13) + 2] = color[2];
                            colorData[4 * (vtxCursor * 7 + 13) + 3] = 255;
                            vtxCursor += 2;

                            indexData[idxCursor + 0] = vtxCursor - 4;
                            indexData[idxCursor + 1] = vtxCursor - 3;
                            indexData[idxCursor + 2] = vtxCursor - 2;
                            indexData[idxCursor + 3] = vtxCursor - 3;
                            indexData[idxCursor + 4] = vtxCursor - 1;
                            indexData[idxCursor + 5] = vtxCursor - 2;
                            idxCursor += 6;

                            // There is no next vertex.
                            s.current = null;
                        }

                        // Upload data to the GPU.
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);

                        // Record number of indices.
                        this.indexBufferSize = indexData.length;
                    }
                });

                // Subclass the layer view from GraphicsLayer, to take advantage of its
                // watchable graphics property.
                const CustomLayer = GraphicsLayer.createSubclass({
                    createLayerView: function (view) {
                        if (view.type === "2d") {
                            return new CustomLayerView2D({
                                view: view,
                                layer: this
                            });
                        }
                    }
                });

                // var map = new Map({
                //     basemap: "arcgis-dark-gray"
                // });
                var map = new WebMap({ portalItem: { id: "8c547986ba1649d7934ec0331639e738" } });

                var view = new MapView({
                    container: "mapDiv",
                    map: map,
                    padding: { left: 49 },
                    // center: [6.1, 52.5],
                    // zoom: 13
                });

                var travelMode = null;
                networkService.fetchServiceDescription(routeServiceUrl, apiKey).then((serviceDescription) => {
                    // Find the named travel mode called "Walking Time".
                    const { supportedTravelModes } = serviceDescription;
                    travelMode = supportedTravelModes.find((mode) => mode.timeAttributeName === "WalkTime");
                });

                tempBallLayer = new GraphicsLayer();
                tempTreeLayer = new GraphicsLayer();

                map.layers.add(tempTreeLayer);
                map.layers.add(tempBallLayer);
                view.when(() => {

                    ballFLayer = view.map.layers.find((x) => x.title == "Points");
                    tempBallLayer.effect = ballFLayer.effect;

                    origEffectString = ballFLayer.effect;
                    console.log("pointLayer:", ballFLayer);
                    setInterval(SlideHue, 100)

                    treeFLayer = view.map.layers.find((x) => x.title == "Lines");
                    tempTreeLayer.effect = treeFLayer.effect;

                    textFLayer = view.map.layers.find((x) => x.title == "Texts");


                    customTreeLayer = new CustomLayer({
                        graphics: [],
                        minScale: 250000
                    });

                    view.map.layers.add(customTreeLayer, 2);

                    RefreshTreeAnimations(treeFLayer, customTreeLayer);

                    tempCustomTreeLayer = new CustomLayer({
                        graphics: [],
                        minScale: 250000

                    });

                    view.map.layers.add(tempCustomTreeLayer, 2);

                });

                view.on("click", (evt) => {
                    console.log(evt);

                    if (activeID == "createTree") {
                        CreateTree(evt.mapPoint);
                    }

                });

                document.getElementById("btnSaveTree").addEventListener("click", () => {
                    SaveTree()
                });

                var activeID = "";
                //get all the calcite action menu buttons and add click event
                document.querySelectorAll("calcite-action").forEach(function (action) {

                    action.addEventListener("click", function (event) {

                        var actionId = event.target.dataset.actionId;
                        //if the button is pressed twice all panels should close
                        if (actionId == activeID) {
                            actionId = "";
                        }

                        switch (actionId) {
                            case "clearTree": ClearTree(); break;

                        }
                        console.log(`Clicked on action: ${actionId}`)
                        //get all the calcite panels and hide them if it is not the one clicked
                        document.querySelectorAll("calcite-shell-panel > calcite-panel").forEach(function (panel) {

                            panel.hidden = !(panel.getAttribute("data-panel-id") == actionId);
                            panel.active = (panel.getAttribute("data-panel-id") == actionId);

                        });
                        //set the last button id as the active one
                        activeID = actionId;
                    });
                });

                function RefreshTreeAnimations(treeFLayer, customTreeLayer) {
                    console.log("RefreshTreeAnimations");
                    treeFLayer.queryFeatures().then((results) => {
                        var newAnimationGraphcis = []
                        console.log("results", results);
                        var graphics = results.features;
                        results.features.map((feature) => {

                            var geom = feature.geometry;
                            var gengeom = geometryEngine.generalize(geom,50,true,"meters");
                            gengeom.paths.map((path) => {
                                const lineGraphic = {
                                    geometry: {
                                        type: "polyline",
                                        paths: [path],
                                        spatialReference: feature.geometry.spatialReference
                                    },
                                    attributes: { "color": [2, 184, 24] }
                                };
                                newAnimationGraphcis.push(lineGraphic);
                            });
                        });
                        customTreeLayer.graphics = newAnimationGraphcis;

                    });
                }

                function CreateTree(mapPoint) {

                    ClearTree();


                    let routestops = [];
                    // Setup the route parameters
                    const routeParams = new RouteParameters({
                        // An authorization string used to access the routing service
                        apiKey: apiKey,
                        stops: new FeatureSet(),
                        outSpatialReference: {
                            // autocasts as new SpatialReference()
                            wkid: 3857
                        }
                        ,
                        travelMode
                    });

                    let graphic = new Graphic({
                        geometry: mapPoint,
                        symbol: {
                            type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                            color: "yellow",
                            size: 15,
                            outline: { // autocasts as new SimpleLineSymbol()
                                width: 1,
                                color: "black"
                            }
                        }
                        , attributes: { pointtype: "ball3" }
                    });
                    tempBallLayer.add(graphic);

                    routestops[3] = graphic;

                    for (var i = 1; i <= 3; i++) {
                        var newY = mapPoint.y - (yOffset * i);

                        var newX1 = mapPoint.x + (xOffset * i);
                        var newX2 = mapPoint.x - (xOffset * i);
                        if (i % 2 == 0) {
                            console.log("Swapparoo");
                            var nexXTemp = newX1;
                            newX1 = newX2;
                            newX2 = nexXTemp;

                        }

                        let graphic1 = new Graphic({
                            geometry: { x: newX1, y: newY, type: "point", spatialReference: mapPoint.spatialReference },
                            symbol: {
                                type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                                color: "red",
                                size: 15,
                                outline: { // autocasts as new SimpleLineSymbol()
                                    width: 1,
                                    color: "black"
                                }
                            }
                            , attributes: { pointtype: "ball1" }

                        });

                        routestops[3 - i] = graphic1;
                        tempBallLayer.add(graphic1);


                        let graphic2 = new Graphic({
                            geometry: { x: newX2, y: newY, type: "point", spatialReference: mapPoint.spatialReference },
                            symbol: {
                                type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                                color: "green",
                                size: 15,
                                outline: { // autocasts as new SimpleLineSymbol()
                                    width: 1,
                                    color: "black"
                                }
                            }
                            , attributes: { pointtype: "ball2" }

                        });
                        tempBallLayer.add(graphic2);

                        routestops[3 + i] = graphic2;
                    }

                    for (r of routestops) {
                        routeParams.stops.features.push(r);
                    }
                    route.solve(routeServiceUrl, routeParams).then((result) => {
                        const routeResult = result.routeResults[0].route;
                        //var routeResult = new Graphic({ geometry: generateLine(routestops) });

                        var lineLayer = view.map.layers.find((x) => x.title == "Lines");
                        routeResult.symbol = lineLayer.renderer.symbol;

                        tempTreeLayer.add(routeResult);


                        const treeGraphics = routeResult.geometry.paths.map((path) => {
                            const lineGraphic = {
                                geometry: {
                                    type: "polyline",
                                    paths: [path],
                                    spatialReference: routeResult.geometry.spatialReference
                                },
                                attributes: { "color": [2, 184, 24] }
                            };
                            return lineGraphic;
                        });
                        console.log("treegraphics:", treeGraphics);
                        tempCustomTreeLayer.graphics = treeGraphics;


                    });
                }

                function ClearTree() {
                    console.log("clearing trees")
                    tempBallLayer.removeAll();
                    tempTreeLayer.removeAll();
                    tempCustomTreeLayer.removeAll();
                }
                function SaveTree() {
                    console.log("saving tree");

                    var treeInput = document.getElementById("treeName");
                    treeInput.status = "valid";
                    var treename = treeInput.value;
                    if (treename == "") {
                        //alert("Please enter a name for the tree");
                        treeInput.status = "invalid";
                        return;
                    }
                    var newBalls = tempBallLayer.graphics;
                    console.log("newballs:", newBalls);
                    var peakBall = newBalls.find((x) => x.attributes.pointtype == "ball3");
                    var textx = peakBall.geometry.x + (xOffset * 3);
                    var texty = peakBall.geometry.y - (yOffset * 1);
                    var textBall = new Graphic({
                        geometry: { x: textx, y: texty, type: "point", spatialReference: peakBall.geometry.spatialReference }

                        , attributes: { pointtype: "text", description: `Namens: ${treename}` }
                    });
                    newBalls.push(textBall);

                    const pointEditLayer = new FeatureLayer({
                        // URL to the service
                        url: "https://services.arcgis.com/emS4w7iyWEQiulAb/arcgis/rest/services/ChristmasTree_public_add/FeatureServer/0"
                    });


                    const lineEditFLayer = new FeatureLayer({
                        // URL to the service
                        url: "https://services.arcgis.com/emS4w7iyWEQiulAb/arcgis/rest/services/ChristmasTree_public_add/FeatureServer/1"
                    });
                    var ballProm = pointEditLayer.applyEdits({ addFeatures: newBalls })

                    var lineProm = lineEditFLayer.applyEdits({ addFeatures: tempTreeLayer.graphics })

                    Promise.all([ballProm, lineProm]).then((results => {
                        console.log("edits done:", results);
                        view.map.layers.map((layer) => {
                            if (["Points", "Lines", "Texts"].includes(layer.title)) {
                                console.log("refreshing layer:", layer.title);
                                layer.refresh();
                                RefreshTreeAnimations(treeFLayer,customTreeLayer);
                            }
                        })

                        ClearTree();
                    }));

                }

                function SlideHue() {
                    //console.log("SlideHue::Start")
                    currentHue = (currentHue + currentHueDelta);
                    if (currentHue >= 360 || currentHue <= 0) {
                        currentHueDelta = currentHueDelta * -1;
                    }

                    var newEffectString = origEffectString.replace("hue-rotate(360deg)", "hue-rotate(" + currentHue + "deg)");

                    ballFLayer.effect = newEffectString;
                    tempBallLayer.effect = newEffectString;
                    //console.log("new effect:", newEffectString);


                }

                function generateLine(pointGraphics) {
                    let polyline = {
                        type: "polyline",  // autocasts as new Polyline()
                        paths: [

                        ],
                        spatialReference: pointGraphics[0].geometry.spatialReference
                    };

                    for (g of pointGraphics) {
                        polyline.paths.push([g.geometry.x, g.geometry.y]);
                    }
                    return polyline
                }
            });

    </script>
</head>

<body>
    <!-- shell will provide main app layout -->
    <calcite-shell content-behind>
        <!-- custom header for the shell -->
        <div slot="header" id="header">
            <h2 id="header-title">Christmas Card 2021</h2>
        </div>
        <!--The panel for the action bar on the left -->
        <calcite-shell-panel id="primary-panel" slot="primary-panel" position="start" detached>
            <!--The action bar on the left -->
            <calcite-action-bar slot="action-bar" id="actionbar">
                <!--the action bar buttons grouped in two groups -->
                <calcite-action-group>
                    <calcite-action data-action-id="createTree" icon="layers-editable" text="Create a tree">
                    </calcite-action>
                    <calcite-action data-action-id="clearTree" icon="trash" text="Clear tree"></calcite-action>
                    <calcite-action data-action-id="saveTree" icon="save" text="Save tree"></calcite-action>
                </calcite-action-group>
                <calcite-action-group>

                    <calcite-action data-action-id="info" text="Info" icon="information"></calcite-action>
                </calcite-action-group>
            </calcite-action-bar>

            <!--The panels that respond to the buttons, de data-panel-id corresponds to the data-action-id from the buttons-->
            <calcite-panel heading="Save Tree" height-scale="l" width-scale="m" data-panel-id="saveTree" hidden>
                <div id="saveTree-container">
                    <div style="width: 100%; padding: 1rem; box-sizing: border-box;">
                        Name:<br />
                        <calcite-input type="text" label="Name" placeholder="Your name" status="idle" step="any"
                            id="treeName"></calcite-input>
                        <br />

                        <calcite-button alignment="end" appearance="solid" color="blue" scale="m" width="auto"
                            calcite-hydrated="" style="float:right;" id="btnSaveTree">Save</calcite-button>
                    </div>
                    <div style="width: 100%; padding: 1rem; box-sizing: border-box;">&nbsp;</div>

                </div>
            </calcite-panel>

            <calcite-panel heading="Info" height-scale="l" width-scale="m" data-panel-id="info" hidden>
                <div id="info-container" class="info-container" style="padding: 1rem;">
                    <p>
                        Happy Holiday's from the EsriNL Devteam.
                    </p>
                    <p>
                        To create your own christmas tree you need to click on the "Create a tree" button and click on a
                        place on the map.</p>
                    <p>
                        Delete the tree by clicking on the "Clear tree" button.</p>
                    <p>
                        If you want to save your tree in the Service click the "Save Tree" button, give your tree a name
                        and it will saved.

                    </p>

                </div>
            </calcite-panel>

        </calcite-shell-panel>


        <div id="mapDiv"></div>

        <!-- custom footer for the shell -->
        <div slot="footer" id="footer">
            <div class="esri-logo"></div>
        </div>
    </calcite-shell>

</body>

</html>
